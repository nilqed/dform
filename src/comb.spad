)abbrev category LALG LeftAlgebra
++ Author: Larry A. Lambe
++ Date  : 03/01/89; revised 03/17/89; revised 12/02/90.
++ Revision : 22-DEC-2015 / -pretends, +non-atomic symbols 
++ Description: The category of all left algebras over an arbitrary
++ ring.
++
LeftAlgebra(R : Ring) : Category == Join(Ring, LeftModule R) with

      coerce : R -> %
        ++ coerce(r) returns r * 1 where 1 is the identity of the
        ++ left algebra.
        
    add
    
      coerce(x : R) : % == x * 1$%


)abbrev domain EAB ExtAlgBasis
++  Author: Larry Lambe
++  Date created: 03/14/89
++  Description:
++  A domain used in the construction of the exterior algebra on a set
++  X over a ring R.  This domain represents the set of all ordered
++  subsets of the set X, assumed to be in correspondance with
++  {1, 2, 3, ...}.  The ordered subsets are themselves ordered
++  lexicographically and are in bijective correspondance with an ordered
++  basis of the exterior algebra.  In this domain we are dealing strictly
++  with the exponents of basis elements which can only be 0 or 1.
--  Thus we really have L({0, 1}).
++
++  The multiplicative identity element of the exterior algebra corresponds
++  to the empty subset of X.  A coerce from List Integer to an
++  ordered basis element is provided to allow the convenient input of
++  expressions. Another exported function forgets the ordered structure
++  and simply returns the list corresponding to an ordered subset.
++
ExtAlgBasis() : Exports == Implementation where

   I   ==> Integer
   L   ==> List
   NNI ==> NonNegativeInteger

   Exports == OrderedSet with
   
     coerce : List(I) -> %
        ++ coerce(l) converts a list of 0's and 1's into a basis
        ++ element, where 1 (respectively 0) designates that the
        ++ variable of the corresponding index of l is (respectively, is not)
        ++ present.
        ++ Error: if an element of l is not 0 or 1.


     convert : % -> List(I)
        ++ convert to a list of integers

     degree : %   -> NNI
        ++ degree(x) gives the numbers of 1's in x, i.e., the number
        ++ of non-zero exponents in the basis element that x represents.
        
     exponents : %   -> L I
        ++ exponents(x) converts a domain element into a list of zeros
        ++ and ones corresponding to the exponents in the basis element
        ++ that x represents.
        
     Nul : NNI -> %
        ++ Nul() gives the basis element 1 for the algebra generated
        ++ by n generators.


   Implementation == add
   
     Rep := L I

     x, y :  %

     x = y == x =$Rep y

     x < y ==
       null x            => not null y
       null y            => false
       first x = first y => rest x < rest y
       first x > first y

     coerce(li : (L I)) ==
       for x in li repeat
         if x ~= 1 and x ~= 0 then 
           error "coerce: values can only be 0 and 1"
       li

     degree x == (_+/x)::NNI

     exponents x == copy(x @ Rep)

     Nul n == [0 for i in 1..n]

     coerce x == coerce(x @ Rep)$(L I)
     convert(x:%):List(I) == x@Rep
     
     
)abbrev domain ANTISYM AntiSymm
++ Author: Larry A. Lambe
++ Date     : 01/26/91.
++ Revised  : 30 Nov 94
++
++ based on AntiSymmetric '89
++ Needs: ExtAlgBasis, FreeModule(Ring, OrderedSet), LALG, LALG-
++ Description: The domain of antisymmetric polynomials.
++
AntiSymm(R : Ring, lVar : List Symbol) : Exports == Implementation where

  LALG ==> LeftAlgebra
  FMR  ==> FM(R, EAB)
  FM   ==> FreeModule
  I    ==> Integer
  L    ==> List
  EAB  ==> ExtAlgBasis     -- these are exponents of basis elements in order
  NNI  ==> NonNegativeInteger
  O    ==> OutputForm
  base ==> k
  coef ==> c
  Term ==> Record(k : EAB, c : R)

  Exports == Join(LALG(R), RetractableTo(R)) with
  
      leadingCoefficient : % -> R
        ++ leadingCoefficient(p) returns the leading
        ++ coefficient of antisymmetric polynomial p.

      leadingBasisTerm : % -> %
        ++ leadingBasisTerm(p) returns the leading
        ++ basis term of antisymmetric polynomial p.
        
      reductum : % -> %
        ++ reductum(p), where p is an antisymmetric polynomial,
        ++ returns p minus the leading
        ++ term of p if p has at least two terms, and 0 otherwise.
        
      coefficient : (%, %) -> R
        ++ coefficient(p, u) returns the coefficient of
        ++ the term in p containing the basis term u if such
        ++ a term exists, and 0 otherwise.
        ++ Error: if the second argument u is not a basis element.
        
      generator : NNI -> %
        ++ generator(n) returns the nth multiplicative generator,
        ++ a basis term.
        
      exp : L I -> %
        ++  exp([i1, ...in]) returns \spad{u_1\^{i_1} ... u_n\^{i_n}}
        
      homogeneous? : % -> Boolean
        ++  homogeneous?(p) tests if all of the terms of
        ++  p have the same degree.
        
      retractable? : % -> Boolean
        ++  retractable?(p) tests if p is a 0-form,
        ++  i.e., if degree(p) = 0.
        
      degree : % -> NNI
        ++  degree(p) returns the homogeneous degree of p.
        
      map : (R -> R, %) -> %
        ++  map(f, p) changes each coefficient of p by the
        ++  application of f.

      convert : % -> List(Term)
        ++  convert(p) converts p to a list of terms

      convert : List(Term) -> %
        ++  convert a list of terms back to p


  Implementation == FMR add
  
      Rep := L Term

      x, y : EAB
      a, b : %
      r   :  R
      m   :  I

      dim := #lVar

      1 == [[ Nul(dim)$EAB, 1$R ]]
      -- 1 corresponds to the empty monomial Nul = [0, ..., 0]
      -- from EAB. In terms of the exterior algebra on X,
      -- it corresponds to the identity element which lives
      -- in homogeneous degree 0.

      coefficient(a, u) ==
        not null u.rest => error "2nd argument must be a basis element"
        x := u.first.base
        for t in a repeat
          if t.base = x then return t.coef
          if t.base < x then return 0
        0

      retractable?(a) ==
        null a or (a.first.k  =  Nul(dim))

      retractIfCan(a):Union(R,"failed") ==
        null a => 0$R
        a.first.k = Nul(dim) => leadingCoefficient a
        "failed"

      retract(a) : R ==
        null a => 0$R
        leadingCoefficient a

      homogeneous? a ==
        null a => true
        siz := _+/exponents(a.first.base)
        for ta in reductum a repeat
          _+/exponents(ta.base) ~= siz => return false
        true

      degree a ==
        null a => 0$NNI
        homogeneous? a => (_+/exponents(a.first.base)) :: NNI
        error "not a homogeneous element"

      zo : (I, I) -> L I
      zo(p, q) ==
        p = 0 => [1, q]
        q = 0 => [1, 1]
        [0, 0]

      getsgn : (EAB, EAB) -> I
      getsgn(x, y) ==
        sgn : I  := 0
        xx : L I := exponents x
        yy : L I := exponents y
        for i in 1 .. (dim-1) repeat
          xx  := rest xx
          sgn := sgn + (_+/xx)*yy.i
        sgn rem 2 = 0 => 1
        -1

      Nalpha : (EAB, EAB) -> L I
      Nalpha(x, y) ==
        i : I := 1
        dum2 : L I := [0 for i in 1..dim]
        for j in 1..dim repeat
          dum := zo((exponents x).j, (exponents y).j)
          (i := i*dum.1) = 0 => break
          dum2.j := dum.2
        i = 0 => cons(i, dum2)
        cons(getsgn(x, y), dum2)

      a * b ==
        null a => 0
        null b => 0
        ((null a.rest) and (a.first.k = Nul(dim))) => a.first.c * b
        ((null b.rest) and (b.first.k = Nul(dim))) => b.first.c * a
        z : % := 0
        for tb in b repeat
          for ta in a repeat
            stuff := Nalpha(ta.base, tb.base)
            r := first(stuff)*ta.coef*tb.coef
            if r ~= 0 then z := z + [[rest(stuff)::EAB, r]]
        z

      coerce(r) : % ==
        r = 0 => 0
        [ [Nul(dim), r] ]

      coerce(m) : % ==
        m = 0 => 0
        [ [Nul(dim), m::R] ]

      characteristic() == characteristic()$R

      generator(j) ==
        dum : L I := [0 for i in 1..dim]
        dum.j := 1
        [[dum::EAB, 1::R]]

      exp(li : (L I)) ==  [[li::EAB, 1]]

      leadingBasisTerm a ==
        [[a.first.k, 1]]

      displayList : EAB -> O
      displayList(x) : O ==
        le : L I := exponents(x)$EAB
        reduce(_*, [(lVar.i)::O for i in 1..dim | ((le.i) = 1)])$L(O)

      makeTerm : (R, EAB) -> O
      makeTerm(r, x) ==
      -- we know that r ~= 0
        x = Nul(dim)$EAB  => r::O
        (r = 1) => displayList(x)
        r::O * displayList(x)

      coerce(a) : O ==
        zero? a     => 0$I::O
        null rest(a @ Rep) =>
                 t := first(a @ Rep)
                 makeTerm(t.coef, t.base)
        reduce(_+, [makeTerm(t.coef, t.base) for t in (a @ Rep)])$L(O)

      convert(a:%):List(Term) == a@Rep
      convert(t:List Term):% == t



)abbrev domain DERHAM DeRhamComplex
++ Author: Larry A. Lambe
++ Date    : 01/26/91.
++ Revised : 12/01/91.
++
++ based on code from '89 (AntiSymmetric)
++
++ Needs: LeftAlgebra, ExtAlgBasis, FreeMod(Ring, OrderedSet)
++
++ Description: The deRham complex of Euclidean space, that is, the
++ class of differential forms of arbitary degree over a coefficient ring.
++ See Flanders, Harley, Differential Forms, With Applications to the Physical
++ Sciences, New York, Academic Press, 1963.
++
DeRhamComplex(CoefRing, listIndVar) : Exports == Implementation where
  
  CoefRing : Join(Ring, Comparable)
  listIndVar : List Symbol
  
  ASY     ==> AntiSymm(R, listIndVar)
  DIFRING ==> DifferentialRing
  LALG    ==> LeftAlgebra
  FMR     ==> FreeMod(R, EAB)
  I       ==> Integer
  L       ==> List
  EAB     ==> ExtAlgBasis  -- these are exponents of basis elements in order
  NNI     ==> NonNegativeInteger
  O       ==> OutputForm
  R       ==> Expression(CoefRing)
  IF      ==> InputForm
  Term    ==> Record(k : EAB, c : R)


  Exports == Join(LALG(R), RetractableTo(R)) with
  
      leadingCoefficient : % -> R
        ++ leadingCoefficient(df) returns the leading
        ++ coefficient of differential form df.
        
      leadingBasisTerm : % -> %
        ++ leadingBasisTerm(df) returns the leading
        ++ basis term of differential form df.
        
      reductum : % -> %
        ++ reductum(df), where df is a differential form,
        ++ returns df minus the leading
        ++ term of df if df has two or more terms, and
        ++ 0 otherwise.
        
      coefficient : (%, %) -> R
        ++ coefficient(df, u), where df is a differential form,
        ++ returns the coefficient of df containing the basis term u
        ++ if such a term exists, and 0 otherwise.
        
      generator : NNI -> %
        ++ generator(n) returns the nth basis term for a differential form.
        
      homogeneous? : % -> Boolean
        ++  homogeneous?(df) tests if all of the terms of
        ++  differential form df have the same degree.
        
      retractable? : % -> Boolean
        ++  retractable?(df) tests if differential form df is a 0-form,
        ++  i.e., if degree(df) = 0.
        
      degree : % -> NNI
        ++  degree(df) returns the homogeneous degree of differential form df.
        
      map : (R -> R, %) -> %
        ++  map(f, df) replaces each coefficient x of differential
        ++  form df by \spad{f(x)}.
        
      totalDifferential : R -> %
        ++  totalDifferential(x) returns the total differential
        ++  (gradient) form for element x.
        
      exteriorDifferential : % -> %
        ++  exteriorDifferential(df) returns the exterior
        ++  derivative (gradient, curl, divergence, ...) of
        ++  the differential form df.

      dim : % -> NNI
        ++  dim(f) returns the dimension of the base space (#listIndVar)
        
      getCoeffRing : % -> Type
        ++  getCoeffRing(f) returns the coeffcient ring.
        
      getIndVars : % -> List Symbol
        ++  getIndVars(f) returns the list of index variables.

      coerce : % -> List Term
        ++  coerce to a list of low level terms = Record(ExtAlgBasis,R) 

      convert : List Term -> %
        ++  convert a list of terms back: convert(coerce %)=%

        
  Implementation == ASY add
  
      Rep := ASY

      dim := #listIndVar
      
      dim(f) == #listIndVar 

      totalDifferential(f) ==
        dv := [differentiate(f, listIndVar.i)*generator(i)$ASY for i in 1..dim]
        reduce("+",dv)

      termDiff : (R, %) -> %
      termDiff(r, e) ==
        totalDifferential(r) * e

      exteriorDifferential(x) ==
        x = 0 => 0
        termDiff(leadingCoefficient(x)$Rep, leadingBasisTerm x) + _
        exteriorDifferential(reductum x)


      d(s:Symbol):Symbol ==
        ds:=concat["d",string name(s)]::Symbol
        script(ds,scripts(s))
        
      lv := [d(liv) for liv in listIndVar]

      displayList : EAB -> O
      displayList(x) : O ==
        le : L I := exponents(x)$EAB
        reduce(_*, [(lv.i)::O for i in 1..dim | ((le.i) = 1)])$L(O)

      makeTerm : (R, EAB) -> O
      makeTerm(r, x) ==
      -- we know that r ~= 0
        x = Nul(dim)$EAB  => r::O
        (r = 1) => displayList(x)
        r::O * displayList(x)

      terms : % -> List Term
      terms(a) == convert(a)@List Term
      
      getCoeffRing(a) == CoefRing
      getIndVars(a) == listIndVar

      coerce(a:%):List(Term) == convert(a)@List Term  
      
      convert(t:List Term):% == convert(t)$ASY

      coerce(a) : O ==
        a = 0$Rep => 0$I::O
        ta := terms a
        null ta.rest => makeTerm(ta.first.c, ta.first.k)
        reduce(_+, [makeTerm(t.c, t.k) for t in ta])$L(O)

--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

)abbrev package DFORM DifferentialForms
++ Author: Kurt Pagani <nilqed@gmail.com>
++ Date Created: October 2014 
++ Revised: Sat Jan 02 19:52:00 CET 2016
++ License: BSD
++ Description: Differential form methods
++ Requirements: DeRhamComplex (+) 
++ Documentation: nilqed.github.io/TBD
++
DifferentialForms(R,v) : Exports == Implementation where
    
  R: Join(Ring,Comparable) -- IntegralDomain instead of Ring?
  v: List Symbol

  X   ==> Expression R
  OF  ==> OutputForm
  DRC ==> DeRhamComplex(R,v)
  CHC ==> ChainComplex(R,#v)
  BOP ==> BasicOperator
  NNI ==> NonNegativeInteger
  SMR ==> SquareMatrix(#v,X)
  EAB ==> ExtAlgBasis
  REA ==> Record(k : EAB, c : X)
  SGCF ==> SymmetricGroupCombinatoricFunctions
  
  Exports ==  with
    
    _* : (List X, List DRC) -> DRC
    _* : (List DRC, List DRC) -> DRC
    d : DRC -> DRC
    one :  -> DRC
    zero : -> DRC
    baseForms : () -> List DRC
    coordVector : () -> List X
    coordSymbols : () -> List Symbol
    vectorField : Symbol -> List X
    scalarField : Symbol -> X
    covectorField : Symbol -> List DRC
    zeroForm : Symbol -> DRC
    volumeForm : SMR -> DRC
 
    conjBasisTerm : DRC -> DRC
      ++ Return the complement of a basis term w.r.t. volumeForm
 
    atomizeBasisTerm : DRC -> List DRC 
      ++ Given a basis term, e.g. dx*dy*du, atomizeBasisTerm  returns
      ++ a list of the generators (atoms), i.e. [dx,dy,du] for our example.

    monomials : NNI -> List DRC
      ++ List of all monomials of degree p (p in 1..n).
      ++ This is a basis for Lambda(n,p).

    hodgeStar : (SMR,DRC) -> DRC
      ++ computes the Hodge dual of the differential form % with respect
      ++ to a metric g.
        
    dot : (SMR,DRC,DRC) -> X
      ++ computes the inner product of two differential forms w.r.t. g
        
    proj : (NNI,DRC) -> DRC
      ++ projection to homogeneous terms of degree p
   
    interiorProduct : (Vector(X),DRC) -> DRC
      ++ Calculates the interior product i_X(a) of the vector field X
      ++ with the differential form a.
        
    lieDerivative : (Vector(X),DRC) -> DRC
      ++ Calculates the Lie derivative L_X(a) of the differential 
      ++ form a with respect to the vector field X.

    hodgeStar2 :(SMR,DRC) -> DRC
   

  Implementation ==  add 
    
    n:NNI:=#v
    d(f) == exteriorDifferential(f)
    one () == 1@DRC
    zero() == 0@DRC
    baseForms() == [generator(j)$DRC for j in 1..n]
    coordVector() == [s::X for s in v]
    coordSymbols() == v
    
    vectorField(s:Symbol):List X ==
      ls:=[subscript(s,[j::OF]) for j in 1..n]
      op:=[operator t for t in ls]
      x:=[a::X for a in v]
      [f x for f in op]
    
    scalarField(s:Symbol):X ==
      f:=operator s
      f [a::X for a in v]


    covectorField(s:Symbol):List DRC ==
      vf:=vectorField(s)
      [a*1@DRC for a in vf]

    zeroForm(s:Symbol):DRC == scalarField(s)*1@DRC


    (l:List(X) * x:List DRC):DRC == 
      l:List DRC:=[l.j * x.j for j in 1..n]
      reduce(_+,l)

    (x:List DRC * y:List DRC):DRC == 
      l:List DRC:=[x.j * y.j for j in 1..n]
      reduce(_+,l)


    -- error messages
    err1:="CoefRing has not IntegralDomain"
    err2:="Metric tensor is not symmetric"
    err3:="Degenerate metric"
    err4:="Index out of range" 
    err5:="Not implemented"
    err6:="Basis term expected"
    err7:="Zero is not a basis term"


    volumeForm(g:SMR):DRC == 
      not R has IntegralDomain => error(err1)
      sqrt(abs(determinant(g)))*reduce(_*,baseForms())


    monomials(p:NNI):List DRC ==
      bf:=baseForms()
      p=0 => [1$DRC]
      p=1 => bf
      np:=[reverse subSet(n,p,i)$SGCF for i in 0..binomial(n,p)-1]
      [reduce(_*,[bf.(1+s.j) for j in 1..p]) for s in np]


    -- flip 0->1, 1->0 
    flip(b:EAB):EAB ==
      bl := convert(b)$EAB
      [(i+1) rem 2 for i in bl]::EAB


    -- list the positions of a's (a=0,1) in x
    pos(x:EAB, a:Integer):List(Integer) ==
      y:List(Integer):= convert(x)$EAB 
      [j for j in 1..#y | y.j=a]


    -- compute dot of singletons, diagonal g
    dot1(g:SMR,r:REA, s:REA):X ==
      not R has IntegralDomain => error(err1)
      test(r.k ~= s.k) => 0::X
      idx := pos(r.k,1)
      idx = [] => r.c * s.c
      reduce("*",[1/g(j,j) for j in idx]::List(X)) * r.c * s.c


    -- compute dot of singleton terms, general symmetric g
    dot2(g:SMR,r:REA, s:REA):X ==
      not R has IntegralDomain => error(err1)
      pr := pos(r.k,1) -- list positions of 1 in r
      ps := pos(s.k,1) -- list positions of 1 in s
      test(#pr ~= #ps) => 0::X  -- not same degree => 0
      pr = []  => r.c * s.c -- empty pr,ps => product of coefs
      G := inverse(g)::SMR -- compute the inverse of the metric g
      test(#pr = 1) => G(pr.1,ps.1)::X * r.c * s.c -- only one element
      M:Matrix(X) -- the minor
      M := matrix([[G(pr.i,ps.j)::X for j in 1..#ps] for i in 1..#pr])
      determinant(M)::X * r.c * s.c

        
  
    -- export
    dot(g,x,y) ==
      not symmetric? g => error(err2)
      tx:List REA := x::List(REA)
      ty:List REA := y::List(REA)
      tx = [] or ty = [] => 0::X
      if diagonal? g then -- better performance 
        reduce("+",[dot1(g,tx.j,ty.j) for j in 1..#tx])
      else
        reduce("+",[dot2(g,tx.j,ty.j) for j in 1..#tx])

      

    -- export
    hodgeStar2(g,x) ==
      not R has IntegralDomain => error(err1)
      not diagonal? g => error(err5)
      w := sqrt(abs(determinant(g))) -- volume factor
      w = 0 => error(err3)
      t:List(REA) := x::List(REA)
      s := [copy(r) for r in t] -- we need a copy of x!
      for j in 1..#t repeat
        s.j.k := flip(s.j.k)
        fs:= convert([s.j])$DRC
        ft:= convert([t.j])$DRC
        s.j.c := s.j.c * w * dot1(g,t.j,t.j)/leadingCoefficient(ft*fs)
      convert(reverse s)$DRC


    -- export
    --proj0(x,p) ==
    --  p < 0 or p > #v => error(err4)
    --  t:List REA := x::List REA
    --  idx := [j for j in 1..#t | #pos(t.j.k,1)=p]
    --  s := [copy(t.j) for j in idx::List(NNI)]
    --  convert(s)$DRC


    proj(p,x) ==
      x=0 => x
      homogeneous? x and degree(x)=p => x
      a:=leadingBasisTerm(x)
      if degree(a)=p then
        leadingCoefficient(x)*a + proj(p, reductum x)
      else
        proj(p, reductum x)
 

    conjBasisTerm(x:DRC):DRC ==
      x=0$DRC => error(err7)
      x ~= leadingBasisTerm(x) => error(err6)
      t:EAB:=(x::List REA).1.k
      l:List(Integer):=exponents(t)
      m:List(DRC):=[generator(i)$DRC for i in 1..#l | l.i=0]
      m=[] => 1$DRC
      reduce(_*,m)
      
  
    atomizeBasisTerm(x:DRC):List(DRC) ==
      x=0$DRC => error(err7)
      x ~= leadingBasisTerm(x) => error(err6)
      t:EAB:=(x::List REA).1.k
      l:List(Integer):=exponents(t)
      [generator(i)$DRC for i in 1..#l | l.i=1] 


    intProdBasisTerm(w:Vector X, x:DRC):DRC ==
      x ~= leadingBasisTerm(x) => error(err6)
      degree(x)=0 => 0$DRC
      degree(x)=1 => w.position(x,baseForms()) * 1$DRC
      a:List(DRC):=atomizeBasisTerm(x)
      b:DRC:=reduce(_*,rest a)
      -- i_w is an antiderivative => 
      intProdBasisTerm(w,a.1)*b - a.1 * intProdBasisTerm(w,b)
      
        
    interiorProduct(w:Vector X, x:DRC):DRC ==
      x=0$DRC => x
      leadingCoefficient(x)*intProdBasisTerm(w,leadingBasisTerm(x)) + _
        interiorProduct(w, reductum(x))
           
    lieDerivative(w:Vector X,x:DRC):DRC ==
      a := exteriorDifferential(interiorProduct(w,x))
      b := interiorProduct(w, exteriorDifferential(x))
      a+b


--
    --eps0(x:DRC):Integer ==
    --  eta:DRC:=reduce("*",[generator(j)$DRC for j in 1..n])
    --  if opposite?(x*conjBasisTerm(x),eta)$DRC then
    --    return(-1)
    --  else
    --    return 1

    eps(x:DRC):X == leadingCoefficient(x*conjBasisTerm(x))

    hodgeStarBT(g:SMR,x:DRC):DRC ==
      not R has IntegralDomain => error(err1)
      q:=sqrt(abs(determinant(g)))
      p:=degree(x)
      J:=monomials(p)
      s:=[eps(y)*dot(g,y,x)*conjBasisTerm(y) for y in J]
      q*reduce(_+,s)
      
      
    hodgeStar(g:SMR,x:DRC):DRC ==
      x=0$DRC => x
      leadingCoefficient(x)*hodgeStarBT(g,leadingBasisTerm(x)) + _
        hodgeStar(g, reductum(x))
                 